    
    resolve(), 是成功之后的处理函数，对应着.then();

    reject (), 是失败之后的处理函数， 对应着.catch();




例子1:
//then 方法每次都会返回 promise实例对象

function newPromise_resolve() {
   return new Promise((resolve,reject) => {
      resolve(); //这里调resolve方法，则then方法会被调用
      console.log('resolve里面的log');
   })
   //先输出 resolve里面的log
   //后输出 then方法
   //这里很好地体现了 Promise实现了 node.js的异步机制
}

newPromise_resolve().then(() => {
   console.log('then方法');
});

newPromise_resolve();



例子2:

function test(resolve, reject) {
    var timeOut = Math.random() * 2;
    log('set timeout to: ' + timeOut + ' seconds.');
    setTimeout(function () {
        if (timeOut < 1) {
            log('call resolve()...');
            resolve('200 OK');
        }
        else {
            log('call reject()...');
            reject('timeout in ' + timeOut + ' seconds.');
        }
    }, timeOut * 1000);
}
然后：
var p1 = new Promise(test);
var p2 = p1.then(function (result) {
    console.log('成功：' + result);
});
var p3 = p2.catch(function (reason) {
    console.log('失败：' + reason);
});

也可以连起来写：
new Promise(test).then(function (result) {
    console.log('成功：' + result);
}).catch(function (reason) {
    console.log('失败：' + reason);
});


例子3:阿里面试： 封装一个函数，参数是定时器的时间，.then执行回调函数。

      function fn( time ){
          return  new Promise( function(resolve) { setTimeout( resolve, time)}) 
    }

  或者：
      function fn( time ){
          return  new Promise( (resolve) => { return setTimeout (resolve, time)} ) 
    }

或者：
      function fn( time ){
          return  new Promise( (resolve) => setTimeout (resolve, time) ) 
    }

应用： fn( time ).then( )