1.虚拟Dom:  （实现真实Dom对象的js对象）

	Virtual	Dom是一个映射真实Dom的javascript对象。如果需要改变任何元素的状态，那么是先在Virtual Dom上进行改变，就是先改变
	
	对应的js，进而改变真实的Dom对象。当有变化产生时，一个新的Virtual Dom对象会被创建并计算新旧Virtual Dom之间的差别，之后

	差别会应用在真实的Dom上。

例子：

   真实Dom的代码格式：

   <ul	class="list">
	
	<li>item 1</li>

	<li>item 2</li>

   </ul>


   虚拟Dom：（就是在JavaScript中，用对象简单的创造一个针对上面例子的映射)  本质是一个嵌套着数组的原生对象

    {

	type: "ul",															

	props: {"class","list"},

	children:[

		{ type: 'li',props: { }, children:['item 1'] },


		{ type: 'li',props: { }, children:['item 1'] },


		]

	}

	
	当新一项被加进去这个JavaScript对象时，一个函数会计算新旧差异并反映在真实的Dom上，计算诧异的算法是高性能框架的秘密所在。

	Vue和react在计算此差异时略有不同：

	Vue宣称	可以更快的计算出Virtual	Dom的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树，

	而对于react而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然这个可以通过shouldComponentUpdate这个生命周期方法来进行
	控制，但Vue将其视为默认的优化。

	
	【
	  shouldComponentUpdate:（默认渲染行为的问题）

		在react	component的生命周期中，有一个shouldComponentUpdate方法，这个方法默认返回值是true，即：默认重绘。

		这意味着就算没有改变组件的props或者state，也会导致组件的重绘，这就会经常导致组件本来没有任何变化，还是要重绘，
	
		这极大的降低了react的渲染效率。

		
	重写shouldComponentUpdate：

		为了避免这个问题，我们可以在cell组件中重写shouldComponentUpdate方法，只在option发生改变时进行重绘：

		class Cell extends React.Component {

		   shouldComponentUpdate(nextProps, nextState) {

			if (this.props.option === nextProps.option) {
			
			   return false;
			
			} else {

			   return true;

			}

		    }

		}	

		以上代码可以避免重绘问题的发生。

		需要注意的是：在使用shouldComponentUpdate时，需要保证该组件的整个子树的渲染输出都是由该组件的props所决定的，因为只有
		保证组件的渲染输出是props决定的，才能利用shouldComponentUpdate的true或false来判断是否需要渲染。

		在vue应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。


		在解决这一问题时，react也可以通过PureComponent或者immutable.js来解决这一问题，但是PureComponent是浅比较，有一些及时变		
		化了也不会重绘，所以用immutable.js。
	

		】


2.模板与jsx

	vue鼓励去写近似常规HTML的模板，写起来很接近标准HTML元素，（vue在技术上也支持render函数和jsx，但是只是不是默认的而已）

	react推荐所有的模板通用JavaScript的语法扩展---jsx书写	(jsx:遇到{ }就以js的方式解析，遇到<>就以HTML解析）


		