1.钩子函数：

  所有生命周期钩子自动绑定this上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着 你不能使用箭头函数来定义一个生命周期方法 (例如 created: () => this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，
 this.fetchTodos 的行为未定义。

2.父组件向子组件传递数据用props,如果是数据是动态的，就用v-bind动态绑定props的值到父组件的数据中，每当父组件的数据变化时，这种变化也会传递给子组件：

   父组件：<v-header v-bind:seller='seller'></v-header>    //第一个seller是seller这个属性 引号里面的seller是获取到的seller数据

   子组件：export default { props:{ seller: {type:object} } }    //这里的seller指的是seller这个属性

   如果数据是静态 不变的 就不用v-bind指令，直接写seller='seller'就行了

3.vue中引入图片时 不能直接用src  要用v-bind绑定src属性

4.v-if控制加载的内容存不存在

5.如果图片或者是背景图是动态变化的  那么就给需要加图片的元素绑定class属性  再将背景图所在的类名写成数组的形式 传递给class属性

6. 实现图片模糊效果

 css 如下：
.blur {
  filter: blur(6px);
  -webkit-filter: blur(6px);  /* chrome, opera */
  -ms-filter: blur(6px);
  -moz-filter: blur(6px);
  filter:progid:DXImageTransform.Microsoft.Blur(pixelRadius=6,   MakeShadow=false);   /*  IE6~IE9  */
}

7.vue中显示隐藏:

    用v-show="属性名"  在data中定义  属性名：false  元素隐藏 不显示；   属性名：true  元素显示

   在组件中 data是函数的形式：

      data() {
        return {
          detailShow: false
        };
     },

   不在组件中 data就是属性

       data:{ detailShow:false }

8.给元素添加事件：

   先在需要添加事件的元素上加上点击事件  并赋给事件一个方法名  在methods中 定义这个方法  并给这个方法添加函数就是该元素实现的效果

9.sticky footer 的套路
 
    html部分：
   
      <div class="detail-wrapper clearfix">   //外层 并添加清除浮动的类名

           <div class="detail-main"></div>

       </div>
       
       <div class="detail-close"></div>        //与外层齐着

css部分：

 .detail .detail-wrapper{
       min-height:100%;     //必须
     }
  .detail-wrapper .detail-main{
      margin-top:64px;
      padding-bottom:64px;   //必须
     }
.detail .detail-close{
      position:relative;
      width:32px;
      height:32px;
      margin:-64px auto 0 auto;   //必须
      clear:both;
      font-size:32px;
     }

10.如果是计算某个属性的变化 就用computed

   就是vue检测到数据变动时，就会执行对相应数据有引用的函数

   computed与methods的区别：

    methods中的函数必须有一定的触发条件

    computed是在dom加载后马上执行的

11.computed使用方法：

      给发生变化的元素绑定 class属性 并给class赋一个方法名 该方法就是在computed中使用的方法

    <div class="star" v-bind:class="starType"></div>

  export default{
              computed: {
                   starType() {
                        return 'star-'+this.size;
                  }
              }
      }

12.星星分：

    先定义star组件 在外层元素中加的类名分别是star-48、star-36、star-24是定义用哪个尺寸的星星，3个类名分别对应大 中 小星星

    再在内层元素中定义星星的类型 是全圆（on) 还是半圆（half）还是没有圆（off）

    在外层中循环插入5个星星

    在star的父组件中引入star组件  传入必要的数据

   判断圆的类型函数：

      export default {
      props: {
         size: {
            type: Number
         },
         score: {
           type: Number
         }
      },
      computed: {
         starType() {
            return 'star-'+this.size;
         },
         itemClasses() {
            let result=[];
            let score=Math.floor(this.score*2)/2;
            let hasDecimal=score%1!==0;
            let integer=Math.floor(score);
            for (let i=0; i<integer; i++) {
              result.push(CLS_ON);
            }
            if (hasDecimal) {
               result.push(CLS_HALF);
            }
            while (result.length<LENGTH) {
               result.push(CLS_OFF);
            }
            return result;
         }
      }
   };

13.backdrop-filter:blur(10px)   ios上的模糊效果

14.让元素垂直居中 就用display：table


 <ul>
          <li v-for="item in goods" class="food-list">
             <h1 class="title">{{item.name}}</h1>
               <ul>
                  <li v-for="food in item.foods" class="food-item">
                      <div class="icon">
                         <img :src="food.icon"/>
                      </div>
                      <div class="content">
                        <h2 class="name">{{food.name}}</h2>
                        <p class="desc">{{food.description}}</p>
                        <div class="extra">
                           <span>月售{{food.sellCount}}份</span>
                           <span>好评率{{food.rating}}%</span>
                        </div>
                        <div class="price">
                           <span>￥{{food.price}}</span>
                           <span v-show="food.oldPrice">￥{{food.oldPrice}}</span>
                        </div>
                      </div>
                  </li>
               </ul>
          </li>
       </ul>

15.$nestTick :  与计算相关的dom的数据渲染完毕后再执行

16.track-by="$index" ？？？？？？？？？？？？？？？

17.通过在组件渲染的标签中传入参数（数据的键）(父组件）  再在data中通过props传递给子组件数据 来获取数据  从而渲染数据

18.如何获取数据：

  假如子组件要用后台的数据 那么就先在父组件的子组件渲染标签中传入参数来指明要传入的数据  再在子组件的data中用props将父组件的数据传递给子组件 这样 子组件就可以用数据了

19.computed方法：

  先写一个方法名  再写上相关函数 写完后 将结果返回出来， 之后再将方法名以大括号形式写到用该方法的标签内

20.如何根据条件判断是否添加类名
  
   1.只有一个类名加或者不加 highlight

   在标签中加入 :class="{'highlight':totalCount>0}"

   highlight是需要加的类名 后面是条件

   如果totalCount>0  那么就添加类名highlight

方法： 先写好类名 再将类名写在标签中 根据条件判断是否加类名

   2.两个类名 要么加这个类名要么加另一个类名 not-enough 和 enough

    方法是：先在需要加类名的标签中绑定class属性 <div class="pay" :class="payClass"></div>

            再在computed中选择类名：

       payClass() {
          if (this.totalPrice< this.minPrice) {
            return 'not-enough';
          } else {
             return 'enough';
           }
        }

             

21.v-show  显示隐藏

   v-show="totalCount>0"  如果totalCount>0  就显示 totalCount可以是改变的

22.set  ????????????????????

23.动画：
   
 html:
   <transition name="fade">
       .....  要动画的元素
   </transition>

 css:
         .detail{
           position:fixed;
           z-index:100;
           top:0;
           left:0;
           width:100%;
           height:100%;
           overflow:auto;
           background:rgba(7,17,27,0.8);
           backdrop-filter:blur(10px);
           transition: all 0.5s;
        }
       .fade-enter-active,.fade-leave-active{
           opacity:1;
           background:rgba(7,17,27,0.8);
        }
         .fade-enter, .fade-leave-active{
           opacity:0;
           background:rgba(7,17,27,0);
        }

24.如何动态拿到某个元素：

    就是在触发该元素时  派发出一个事件 将dom对象传出来  获取dom的事件  从而就获取到dom

25.
　遇到的问题是：
　　1、如果在App.vue组件ready之前使用Vue.use(VueRouter)，在ready后使用router.start(App_body, '#app')，
       那么会报错“[vue-router] <router-view> can only be used inside a router-enabled app.”
       我猜测是因为App.vue组件并未编译完成，自然在template里面的<router-view></router-view>就找不到了，
       所以在ready之前注册vue-router报这个错。   
  
　　2、如果在组件ready后使用Vue.use(VueRouter)和router.start(App_body, '#app')，
       那么会报错“[Vue warn]: Unknown custom element: <router-view> C did you register the component correctlyhttp://www.toprealgroup.com/web/?
       For recursive components, make sure to provide the "name" option.”
       我猜测是因为App.vue组件ready之前，发现template中有<router-view></router-view>组件，而这个组件还没有被注册